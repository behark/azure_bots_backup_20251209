#!/usr/bin/env python3
"""
Simple Backtesting Framework for Trading Bots
Allows testing strategies on historical data before live deployment.
"""

import json
import logging
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Callable
import ccxt

logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
logger = logging.getLogger("backtest")


@dataclass
class Trade:
    """Represents a single trade."""
    symbol: str
    direction: str  # LONG or SHORT
    entry_price: float
    entry_time: datetime
    stop_loss: float
    take_profit_1: float
    take_profit_2: float
    exit_price: Optional[float] = None
    exit_time: Optional[datetime] = None
    result: Optional[str] = None  # TP1, TP2, SL
    pnl_pct: float = 0.0


@dataclass
class BacktestResult:
    """Results from a backtest run."""
    strategy_name: str
    symbol: str
    timeframe: str
    start_date: str
    end_date: str
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    win_rate: float = 0.0
    total_pnl_pct: float = 0.0
    avg_win_pct: float = 0.0
    avg_loss_pct: float = 0.0
    max_drawdown_pct: float = 0.0
    profit_factor: float = 0.0
    trades: List[Trade] = field(default_factory=list)


class Backtester:
    """
    Simple backtesting engine for trading strategies.
    
    Usage:
        backtester = Backtester()
        result = backtester.run(
            strategy_fn=my_strategy,
            symbol="BTC",
            timeframe="15m",
            start_date="2024-01-01",
            end_date="2024-12-01"
        )
    """
    
    def __init__(self, exchange: str = "binanceusdm"):
        self.exchange_name = exchange
        self.exchange = self._init_exchange(exchange)
    
    def _init_exchange(self, exchange_name: str) -> ccxt.Exchange:
        """Initialize exchange client."""
        exchanges = {
            "binanceusdm": ccxt.binanceusdm,
            "mexc": ccxt.mexc,
            "bybit": ccxt.bybit,
        }
        if exchange_name not in exchanges:
            raise ValueError(f"Unsupported exchange: {exchange_name}")
        
        return exchanges[exchange_name]({"enableRateLimit": True})
    
    def fetch_historical_data(
        self,
        symbol: str,
        timeframe: str,
        start_date: str,
        end_date: str,
    ) -> List[Dict]:
        """
        Fetch historical OHLCV data from exchange.
        
        Returns list of candles: [timestamp, open, high, low, close, volume]
        """
        market_symbol = f"{symbol}/USDT:USDT"
        
        start_ts = int(datetime.fromisoformat(start_date).timestamp() * 1000)
        end_ts = int(datetime.fromisoformat(end_date).timestamp() * 1000)
        
        all_candles = []
        current_ts = start_ts
        
        logger.info(f"Fetching historical data for {symbol} from {start_date} to {end_date}")
        
        while current_ts < end_ts:
            try:
                candles = self.exchange.fetch_ohlcv(
                    market_symbol,
                    timeframe=timeframe,
                    since=current_ts,
                    limit=1000
                )
                
                if not candles:
                    break
                
                all_candles.extend(candles)
                current_ts = candles[-1][0] + 1
                
            except Exception as e:
                logger.error(f"Error fetching data: {e}")
                break
        
        # Convert to dict format
        result = []
        for candle in all_candles:
            if candle[0] <= end_ts:
                result.append({
                    "timestamp": candle[0],
                    "datetime": datetime.fromtimestamp(candle[0] / 1000),
                    "open": candle[1],
                    "high": candle[2],
                    "low": candle[3],
                    "close": candle[4],
                    "volume": candle[5],
                })
        
        logger.info(f"Fetched {len(result)} candles")
        return result
    
    def run(
        self,
        strategy_fn: Callable,
        symbol: str,
        timeframe: str,
        start_date: str,
        end_date: str,
        strategy_name: str = "Unknown Strategy",
    ) -> BacktestResult:
        """
        Run backtest for a strategy.
        
        Args:
            strategy_fn: Function that takes candles and returns signal dict or None
                         Signal format: {"direction": "LONG/SHORT", "entry": float, 
                                        "sl": float, "tp1": float, "tp2": float}
            symbol: Trading symbol (e.g., "BTC")
            timeframe: Candle timeframe (e.g., "15m")
            start_date: Start date (ISO format)
            end_date: End date (ISO format)
            strategy_name: Name for the strategy
            
        Returns:
            BacktestResult with all statistics
        """
        candles = self.fetch_historical_data(symbol, timeframe, start_date, end_date)
        
        if len(candles) < 100:
            logger.warning("Not enough data for backtesting")
            return BacktestResult(
                strategy_name=strategy_name,
                symbol=symbol,
                timeframe=timeframe,
                start_date=start_date,
                end_date=end_date,
            )
        
        result = BacktestResult(
            strategy_name=strategy_name,
            symbol=symbol,
            timeframe=timeframe,
            start_date=start_date,
            end_date=end_date,
        )
        
        open_trade: Optional[Trade] = None
        
        # Walk through candles
        for i in range(100, len(candles)):
            current_candle = candles[i]
            historical_candles = candles[i-100:i]
            
            # Check if we have an open trade
            if open_trade:
                # Check for TP/SL hits
                exit_result = self._check_trade_exit(open_trade, current_candle)
                if exit_result:
                    exit_price: float = float(exit_result["price"])
                    open_trade.exit_price = exit_price
                    open_trade.exit_time = current_candle["datetime"]
                    open_trade.result = exit_result["result"]
                    open_trade.pnl_pct = self._calculate_pnl(
                        open_trade.direction,
                        open_trade.entry_price,
                        exit_price,
                    )
                    result.trades.append(open_trade)
                    open_trade = None
            
            # Only look for new signals if no open trade
            if not open_trade:
                signal = strategy_fn(historical_candles)
                if signal:
                    open_trade = Trade(
                        symbol=symbol,
                        direction=signal["direction"],
                        entry_price=signal["entry"],
                        entry_time=current_candle["datetime"],
                        stop_loss=signal["sl"],
                        take_profit_1=signal["tp1"],
                        take_profit_2=signal["tp2"],
                    )
        
        # Calculate statistics
        self._calculate_statistics(result)
        
        return result
    
    def _check_trade_exit(self, trade: Trade, candle: Dict) -> Optional[Dict]:
        """Check if trade hit TP or SL."""
        high = candle["high"]
        low = candle["low"]
        
        if trade.direction == "LONG":
            if low <= trade.stop_loss:
                return {"result": "SL", "price": trade.stop_loss}
            if high >= trade.take_profit_2:
                return {"result": "TP2", "price": trade.take_profit_2}
            if high >= trade.take_profit_1:
                return {"result": "TP1", "price": trade.take_profit_1}
        else:  # SHORT
            if high >= trade.stop_loss:
                return {"result": "SL", "price": trade.stop_loss}
            if low <= trade.take_profit_2:
                return {"result": "TP2", "price": trade.take_profit_2}
            if low <= trade.take_profit_1:
                return {"result": "TP1", "price": trade.take_profit_1}
        
        return None
    
    @staticmethod
    def _calculate_pnl(direction: str, entry: float, exit_price: float) -> float:
        """Calculate PnL percentage."""
        if entry == 0:
            return 0.0
        if direction == "LONG":
            return ((exit_price - entry) / entry) * 100
        return ((entry - exit_price) / entry) * 100
    
    def _calculate_statistics(self, result: BacktestResult) -> None:
        """Calculate backtest statistics."""
        if not result.trades:
            return
        
        result.total_trades = len(result.trades)
        
        wins = [t for t in result.trades if t.result and t.result.startswith("TP")]
        losses = [t for t in result.trades if t.result == "SL"]
        
        result.winning_trades = len(wins)
        result.losing_trades = len(losses)
        result.win_rate = (result.winning_trades / result.total_trades) * 100 if result.total_trades > 0 else 0
        
        result.total_pnl_pct = sum(t.pnl_pct for t in result.trades)
        
        if wins:
            result.avg_win_pct = sum(t.pnl_pct for t in wins) / len(wins)
        if losses:
            result.avg_loss_pct = sum(t.pnl_pct for t in losses) / len(losses)
        
        # Calculate max drawdown
        cumulative_pnl = 0
        peak = 0
        max_drawdown = 0
        for trade in result.trades:
            cumulative_pnl += trade.pnl_pct
            peak = max(peak, cumulative_pnl)
            drawdown = peak - cumulative_pnl
            max_drawdown = max(max_drawdown, drawdown)
        result.max_drawdown_pct = max_drawdown
        
        # Profit factor
        total_wins = sum(t.pnl_pct for t in wins) if wins else 0
        total_losses = abs(sum(t.pnl_pct for t in losses)) if losses else 0
        result.profit_factor = total_wins / total_losses if total_losses > 0 else float('inf')
    
    def print_report(self, result: BacktestResult) -> None:
        """Print backtest report."""
        print("\n" + "=" * 60)
        print(f"BACKTEST REPORT: {result.strategy_name}")
        print("=" * 60)
        print(f"Symbol: {result.symbol} | Timeframe: {result.timeframe}")
        print(f"Period: {result.start_date} to {result.end_date}")
        print("-" * 60)
        print(f"Total Trades:     {result.total_trades}")
        print(f"Winning Trades:   {result.winning_trades}")
        print(f"Losing Trades:    {result.losing_trades}")
        print(f"Win Rate:         {result.win_rate:.1f}%")
        print("-" * 60)
        print(f"Total PnL:        {result.total_pnl_pct:+.2f}%")
        print(f"Avg Win:          {result.avg_win_pct:+.2f}%")
        print(f"Avg Loss:         {result.avg_loss_pct:+.2f}%")
        print(f"Max Drawdown:     {result.max_drawdown_pct:.2f}%")
        print(f"Profit Factor:    {result.profit_factor:.2f}")
        print("=" * 60 + "\n")
    
    def save_report(self, result: BacktestResult, file_path: Path) -> None:
        """Save backtest report to JSON file."""
        data = {
            "strategy_name": result.strategy_name,
            "symbol": result.symbol,
            "timeframe": result.timeframe,
            "start_date": result.start_date,
            "end_date": result.end_date,
            "statistics": {
                "total_trades": result.total_trades,
                "winning_trades": result.winning_trades,
                "losing_trades": result.losing_trades,
                "win_rate": result.win_rate,
                "total_pnl_pct": result.total_pnl_pct,
                "avg_win_pct": result.avg_win_pct,
                "avg_loss_pct": result.avg_loss_pct,
                "max_drawdown_pct": result.max_drawdown_pct,
                "profit_factor": result.profit_factor,
            },
            "trades": [
                {
                    "symbol": t.symbol,
                    "direction": t.direction,
                    "entry_price": t.entry_price,
                    "entry_time": t.entry_time.isoformat() if t.entry_time else None,
                    "exit_price": t.exit_price,
                    "exit_time": t.exit_time.isoformat() if t.exit_time else None,
                    "result": t.result,
                    "pnl_pct": t.pnl_pct,
                }
                for t in result.trades
            ],
        }
        file_path.write_text(json.dumps(data, indent=2))
        logger.info(f"Report saved to {file_path}")


# Example strategy function
def example_simple_ma_strategy(candles: List[Dict]) -> Optional[Dict]:
    """
    Example: Simple moving average crossover strategy.
    
    Buy when price crosses above 20-period SMA.
    Sell when price crosses below 20-period SMA.
    """
    if len(candles) < 20:
        return None
    
    closes = [c["close"] for c in candles]
    sma20 = sum(closes[-20:]) / 20
    current_price = closes[-1]
    prev_price = closes[-2]
    
    atr = _calculate_atr(candles[-14:])
    
    # Bullish crossover
    if prev_price < sma20 and current_price > sma20:
        return {
            "direction": "LONG",
            "entry": current_price,
            "sl": current_price - (atr * 1.5),
            "tp1": current_price + (atr * 2),
            "tp2": current_price + (atr * 3),
        }
    
    # Bearish crossover
    if prev_price > sma20 and current_price < sma20:
        return {
            "direction": "SHORT",
            "entry": current_price,
            "sl": current_price + (atr * 1.5),
            "tp1": current_price - (atr * 2),
            "tp2": current_price - (atr * 3),
        }
    
    return None


def _calculate_atr(candles: List[Dict], period: int = 14) -> float:
    """Calculate Average True Range."""
    if len(candles) < 2:
        return candles[-1]["high"] - candles[-1]["low"] if candles else 0
    
    trs = []
    for i in range(1, len(candles)):
        high = candles[i]["high"]
        low = candles[i]["low"]
        prev_close = candles[i-1]["close"]
        tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
        trs.append(tr)
    
    return sum(trs) / len(trs) if trs else 0


if __name__ == "__main__":
    # Example usage
    backtester = Backtester(exchange="binanceusdm")
    
    result = backtester.run(
        strategy_fn=example_simple_ma_strategy,
        symbol="BTC",
        timeframe="15m",
        start_date="2024-11-01",
        end_date="2024-12-01",
        strategy_name="Simple MA Crossover",
    )
    
    backtester.print_report(result)
    backtester.save_report(result, Path("backtest_result.json"))
